// Autogenerated from Pigeon (v2.0.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "Steps.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSDictionary<NSString *, id> *wrapResult(id result, FlutterError *error) {
  NSDictionary *errorDict = (NSDictionary *)[NSNull null];
  if (error) {
    errorDict = @{
        @"code": (error.code ? error.code : [NSNull null]),
        @"message": (error.message ? error.message : [NSNull null]),
        @"details": (error.details ? error.details : [NSNull null]),
        };
  }
  return @{
      @"result": (result ? result : [NSNull null]),
      @"error": errorDict,
      };
}
static id GetNullableObject(NSDictionary* dict, id key) {
  id result = dict[key];
  return (result == [NSNull null]) ? nil : result;
}
static id GetNullableObjectAtIndex(NSArray* array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}


@interface NativeStepList ()
+ (NativeStepList *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NativeStep ()
+ (NativeStep *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface StandUpHourResult ()
+ (StandUpHourResult *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface StandUpResultInDate ()
+ (StandUpResultInDate *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface StandUpRequestDuration ()
+ (StandUpRequestDuration *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface StandUpResults ()
+ (StandUpResults *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FitnessRequestPermissionResultObject ()
+ (FitnessRequestPermissionResultObject *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end

@implementation NativeStepList
+ (instancetype)makeWithRecords:(nullable NSArray<NativeStep *> *)records {
  NativeStepList* pigeonResult = [[NativeStepList alloc] init];
  pigeonResult.records = records;
  return pigeonResult;
}
+ (NativeStepList *)fromMap:(NSDictionary *)dict {
  NativeStepList *pigeonResult = [[NativeStepList alloc] init];
  pigeonResult.records = GetNullableObject(dict, @"records");
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.records ? self.records : [NSNull null]), @"records", nil];
}
@end

@implementation NativeStep
+ (instancetype)makeWithDate:(nullable NSString *)date
    distance:(nullable NSNumber *)distance
    steps:(nullable NSNumber *)steps {
  NativeStep* pigeonResult = [[NativeStep alloc] init];
  pigeonResult.date = date;
  pigeonResult.distance = distance;
  pigeonResult.steps = steps;
  return pigeonResult;
}
+ (NativeStep *)fromMap:(NSDictionary *)dict {
  NativeStep *pigeonResult = [[NativeStep alloc] init];
  pigeonResult.date = GetNullableObject(dict, @"date");
  pigeonResult.distance = GetNullableObject(dict, @"distance");
  pigeonResult.steps = GetNullableObject(dict, @"steps");
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.date ? self.date : [NSNull null]), @"date", (self.distance ? self.distance : [NSNull null]), @"distance", (self.steps ? self.steps : [NSNull null]), @"steps", nil];
}
@end

@implementation StandUpHourResult
+ (instancetype)makeWithHour:(nullable NSNumber *)hour
    result:(StandUpResult)result {
  StandUpHourResult* pigeonResult = [[StandUpHourResult alloc] init];
  pigeonResult.hour = hour;
  pigeonResult.result = result;
  return pigeonResult;
}
+ (StandUpHourResult *)fromMap:(NSDictionary *)dict {
  StandUpHourResult *pigeonResult = [[StandUpHourResult alloc] init];
  pigeonResult.hour = GetNullableObject(dict, @"hour");
  pigeonResult.result = [GetNullableObject(dict, @"result") integerValue];
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.hour ? self.hour : [NSNull null]), @"hour", @(self.result), @"result", nil];
}
@end

@implementation StandUpResultInDate
+ (instancetype)makeWithValue:(nullable NSArray<StandUpHourResult *> *)value
    errorMessage:(nullable NSString *)errorMessage {
  StandUpResultInDate* pigeonResult = [[StandUpResultInDate alloc] init];
  pigeonResult.value = value;
  pigeonResult.errorMessage = errorMessage;
  return pigeonResult;
}
+ (StandUpResultInDate *)fromMap:(NSDictionary *)dict {
  StandUpResultInDate *pigeonResult = [[StandUpResultInDate alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  pigeonResult.errorMessage = GetNullableObject(dict, @"errorMessage");
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.value ? self.value : [NSNull null]), @"value", (self.errorMessage ? self.errorMessage : [NSNull null]), @"errorMessage", nil];
}
@end

@implementation StandUpRequestDuration
+ (instancetype)makeWithDateFormat:(nullable NSString *)dateFormat
    startDate:(nullable NSString *)startDate
    endDate:(nullable NSString *)endDate {
  StandUpRequestDuration* pigeonResult = [[StandUpRequestDuration alloc] init];
  pigeonResult.dateFormat = dateFormat;
  pigeonResult.startDate = startDate;
  pigeonResult.endDate = endDate;
  return pigeonResult;
}
+ (StandUpRequestDuration *)fromMap:(NSDictionary *)dict {
  StandUpRequestDuration *pigeonResult = [[StandUpRequestDuration alloc] init];
  pigeonResult.dateFormat = GetNullableObject(dict, @"dateFormat");
  pigeonResult.startDate = GetNullableObject(dict, @"startDate");
  pigeonResult.endDate = GetNullableObject(dict, @"endDate");
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.dateFormat ? self.dateFormat : [NSNull null]), @"dateFormat", (self.startDate ? self.startDate : [NSNull null]), @"startDate", (self.endDate ? self.endDate : [NSNull null]), @"endDate", nil];
}
@end

@implementation StandUpResults
+ (instancetype)makeWithDuration:(nullable StandUpRequestDuration *)duration
    results:(nullable NSDictionary<NSString *, NSArray<id> *> *)results {
  StandUpResults* pigeonResult = [[StandUpResults alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.results = results;
  return pigeonResult;
}
+ (StandUpResults *)fromMap:(NSDictionary *)dict {
  StandUpResults *pigeonResult = [[StandUpResults alloc] init];
  pigeonResult.duration = [StandUpRequestDuration fromMap:GetNullableObject(dict, @"duration")];
  pigeonResult.results = GetNullableObject(dict, @"results");
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.duration ? [self.duration toMap] : [NSNull null]), @"duration", (self.results ? self.results : [NSNull null]), @"results", nil];
}
@end

@implementation FitnessRequestPermissionResultObject
+ (instancetype)makeWithValue:(FitnessRequestPermissionResult)value {
  FitnessRequestPermissionResultObject* pigeonResult = [[FitnessRequestPermissionResultObject alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (FitnessRequestPermissionResultObject *)fromMap:(NSDictionary *)dict {
  FitnessRequestPermissionResultObject *pigeonResult = [[FitnessRequestPermissionResultObject alloc] init];
  pigeonResult.value = [GetNullableObject(dict, @"value") integerValue];
  return pigeonResult;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:@(self.value), @"value", nil];
}
@end

@interface FlutterCallNativeApiCodecReader : FlutterStandardReader
@end
@implementation FlutterCallNativeApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NativeStep fromMap:[self readValue]];
    
    case 129:     
      return [NativeStepList fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FlutterCallNativeApiCodecWriter : FlutterStandardWriter
@end
@implementation FlutterCallNativeApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NativeStep class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NativeStepList class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FlutterCallNativeApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FlutterCallNativeApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FlutterCallNativeApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FlutterCallNativeApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FlutterCallNativeApiGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FlutterCallNativeApiCodecReaderWriter *readerWriter = [[FlutterCallNativeApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FlutterCallNativeApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FlutterCallNativeApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallNativeApi.getTodayStep"
        binaryMessenger:binaryMessenger
        codec:FlutterCallNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getTodayStepWithCompletion:)], @"FlutterCallNativeApi api (%@) doesn't respond to @selector(getTodayStepWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getTodayStepWithCompletion:^(NativeStep *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallNativeApi.getHistorySteps"
        binaryMessenger:binaryMessenger
        codec:FlutterCallNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getHistoryStepsWithCompletion:)], @"FlutterCallNativeApi api (%@) doesn't respond to @selector(getHistoryStepsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getHistoryStepsWithCompletion:^(NativeStepList *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallNativeApi.getLast2DaysSteps"
        binaryMessenger:binaryMessenger
        codec:FlutterCallNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getLast2DaysStepsWithCompletion:)], @"FlutterCallNativeApi api (%@) doesn't respond to @selector(getLast2DaysStepsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getLast2DaysStepsWithCompletion:^(NativeStepList *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallNativeApi.getSteps"
        binaryMessenger:binaryMessenger
        codec:FlutterCallNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStepsStartDate:endDate:completion:)], @"FlutterCallNativeApi api (%@) doesn't respond to @selector(getStepsStartDate:endDate:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_startDate = GetNullableObjectAtIndex(args, 0);
        NSString *arg_endDate = GetNullableObjectAtIndex(args, 1);
        [api getStepsStartDate:arg_startDate endDate:arg_endDate completion:^(NativeStepList *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FlutterCallIosNativeApiCodecReader : FlutterStandardReader
@end
@implementation FlutterCallIosNativeApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NativeStep fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FlutterCallIosNativeApiCodecWriter : FlutterStandardWriter
@end
@implementation FlutterCallIosNativeApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NativeStep class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FlutterCallIosNativeApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FlutterCallIosNativeApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FlutterCallIosNativeApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FlutterCallIosNativeApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FlutterCallIosNativeApiGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FlutterCallIosNativeApiCodecReaderWriter *readerWriter = [[FlutterCallIosNativeApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FlutterCallIosNativeApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FlutterCallIosNativeApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallIosNativeApi.healthAuthorizationRequestMethod"
        binaryMessenger:binaryMessenger
        codec:FlutterCallIosNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(healthAuthorizationRequestMethodWithCompletion:)], @"FlutterCallIosNativeApi api (%@) doesn't respond to @selector(healthAuthorizationRequestMethodWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api healthAuthorizationRequestMethodWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallIosNativeApi.isHealthKitDenied"
        binaryMessenger:binaryMessenger
        codec:FlutterCallIosNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isHealthKitDeniedWithCompletion:)], @"FlutterCallIosNativeApi api (%@) doesn't respond to @selector(isHealthKitDeniedWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api isHealthKitDeniedWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FlutterCallIosNativeApi.monitorBackgroundStepChanged"
        binaryMessenger:binaryMessenger
        codec:FlutterCallIosNativeApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(monitorBackgroundStepChangedWithCompletion:)], @"FlutterCallIosNativeApi api (%@) doesn't respond to @selector(monitorBackgroundStepChangedWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api monitorBackgroundStepChangedWithCompletion:^(NativeStep *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface NativeCallFlutterApiCodecReader : FlutterStandardReader
@end
@implementation NativeCallFlutterApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NativeStep fromMap:[self readValue]];
    
    case 129:     
      return [NativeStepList fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface NativeCallFlutterApiCodecWriter : FlutterStandardWriter
@end
@implementation NativeCallFlutterApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NativeStep class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NativeStepList class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface NativeCallFlutterApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NativeCallFlutterApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NativeCallFlutterApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NativeCallFlutterApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NativeCallFlutterApiGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    NativeCallFlutterApiCodecReaderWriter *readerWriter = [[NativeCallFlutterApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface NativeCallFlutterApi ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation NativeCallFlutterApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)uploadBackgroundLast2DaysStepsList:(NativeStepList *)arg_list completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NativeCallFlutterApi.uploadBackgroundLast2DaysSteps"
      binaryMessenger:self.binaryMessenger
      codec:NativeCallFlutterApiGetCodec()];
  [channel sendMessage:@[(arg_list == nil) ? [NSNull null] : arg_list] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)showLocalNotificationWithCompletion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NativeCallFlutterApi.showLocalNotification"
      binaryMessenger:self.binaryMessenger
      codec:NativeCallFlutterApiGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface StandUpApiCodecReader : FlutterStandardReader
@end
@implementation StandUpApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [StandUpHourResult fromMap:[self readValue]];
    
    case 129:     
      return [StandUpRequestDuration fromMap:[self readValue]];
    
    case 130:     
      return [StandUpResultInDate fromMap:[self readValue]];
    
    case 131:     
      return [StandUpResults fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface StandUpApiCodecWriter : FlutterStandardWriter
@end
@implementation StandUpApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[StandUpHourResult class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StandUpRequestDuration class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StandUpResultInDate class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StandUpResults class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface StandUpApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation StandUpApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[StandUpApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[StandUpApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *StandUpApiGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    StandUpApiCodecReaderWriter *readerWriter = [[StandUpApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void StandUpApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<StandUpApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StandUpApi.getStandUpAt"
        binaryMessenger:binaryMessenger
        codec:StandUpApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStandUpAtDate:dateFormat:completion:)], @"StandUpApi api (%@) doesn't respond to @selector(getStandUpAtDate:dateFormat:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_date = GetNullableObjectAtIndex(args, 0);
        NSString *arg_dateFormat = GetNullableObjectAtIndex(args, 1);
        [api getStandUpAtDate:arg_date dateFormat:arg_dateFormat completion:^(StandUpResultInDate *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StandUpApi.getStandUp"
        binaryMessenger:binaryMessenger
        codec:StandUpApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStandUpDuration:completion:)], @"StandUpApi api (%@) doesn't respond to @selector(getStandUpDuration:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StandUpRequestDuration *arg_duration = GetNullableObjectAtIndex(args, 0);
        [api getStandUpDuration:arg_duration completion:^(StandUpResults *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface AndroidFitnessApiCodecReader : FlutterStandardReader
@end
@implementation AndroidFitnessApiCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FitnessRequestPermissionResultObject fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface AndroidFitnessApiCodecWriter : FlutterStandardWriter
@end
@implementation AndroidFitnessApiCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FitnessRequestPermissionResultObject class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface AndroidFitnessApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AndroidFitnessApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AndroidFitnessApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AndroidFitnessApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AndroidFitnessApiGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    AndroidFitnessApiCodecReaderWriter *readerWriter = [[AndroidFitnessApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void AndroidFitnessApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AndroidFitnessApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AndroidFitnessApi.googleSignInHasPermissions"
        binaryMessenger:binaryMessenger
        codec:AndroidFitnessApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(googleSignInHasPermissionsWithCompletion:)], @"AndroidFitnessApi api (%@) doesn't respond to @selector(googleSignInHasPermissionsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api googleSignInHasPermissionsWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AndroidFitnessApi.requestFitnessPermissionStatus"
        binaryMessenger:binaryMessenger
        codec:AndroidFitnessApiGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestFitnessPermissionStatusWithCompletion:)], @"AndroidFitnessApi api (%@) doesn't respond to @selector(requestFitnessPermissionStatusWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestFitnessPermissionStatusWithCompletion:^(FitnessRequestPermissionResultObject *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
